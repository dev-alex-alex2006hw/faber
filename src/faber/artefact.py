#
# Copyright (c) 2016 Stefan Seefeld
# All rights reserved.
#
# This file is part of Faber. It is made available under the
# Boost Software License, Version 1.0.
# (Consult LICENSE or http://www.boost.org/LICENSE_1_0.txt)

from .utils import path_formatter
from os.path import normpath, join
from collections import defaultdict
from functools import reduce

intermediate= 0x0001
nocare= 0x0002
notfile= 0x0004
always= 0x0008
leaves= 0x0010
noupdate= 0x0020
rmold= 0x0080
xfail= 0x0100
isfile= 0x0400
precious= 0x0800


class artefact(object):
    """An artefact can be generated by a build."""

    _path_formatter = path_formatter()
    _qnames = defaultdict(list)

    @staticmethod
    def finish():
        artefact._qnames.clear()

    @staticmethod
    def iter():
        """Iterate over all registered artefacts."""

        return iter(a for qname in artefact._qnames.values() for a in qname)

    @staticmethod
    def lookup(qname):
        """Find an artefact by (qualified) name."""

        if qname not in artefact._qnames:
            raise KeyError(qname)
        else:
            return artefact._qnames[qname]

    @classmethod
    def instantiate(cls, a, module):
        return a if isinstance(a, artefact) else cls(a, module=module)

    @staticmethod
    def combine_use(artefacts):
        """return the union of the use features from all artefacts"""
        return reduce(lambda fs, a: fs|a.use, artefacts, set())

    @property
    def qname(self):
        """The qualified name of this artefact."""
        return self.module.qname(self.name)

    @property
    def id(self):
        """Yield a unique identifier for this artefact."""
        return '%s-%x' % (self.qname, id(self))

    @property
    def isfile(self):
        """Just a convenience property for a frequent query"""
        return not self.attrs & notfile

    @property
    def _filename(self):
        """The (full) filename of this artefact, if it represents a file."""
        return normpath(join(self.module.builddir, self.name))

    @property
    def boundname(self):
        """Return either self.filename or self.qname depending on whether
        this artefact represents a file."""
        return self._filename if self.isfile else self.qname

    def __init__(self, name, attrs=0, module=None,
                 features=(), use=(),
                 path_spec=''):
        self.name = name
        from .module import module as M
        self.module = module or M.current
        self.attrs = attrs
        self.path_spec = path_spec
        self.status = None
        self._register()

    def _register(self):
        from . import scheduler
        artefact._qnames[self.qname].append(self)
        scheduler.define_target(self)

    def __str__(self):
        return '<{} {}>'.format(self.__class__.__name__, self.qname)

    def __repr__(self):
        return '<{} {}>'.format(self.__class__.__name__, self.id)

    def __status__(self, status):
        self.status = status


class source(artefact):
    """A source is a simple feature-less artefact representing an existing
    file outside faber's control."""

    _instances = {}

    def __new__(cls, name, module):
        """Make sure there is only one instance per source (file)."""
        qname = module.qname(name)
        if qname not in cls._instances:
            cls._instances[qname] = object.__new__(cls)
        return cls._instances[qname]

    def _register(self):
        # don't depend on anything
        from . import scheduler
        artefact._qnames[self.qname].append(self)
        scheduler.define_target(self)

    @property
    def _filename(self):
        return join(self.module.srcdir, self.name)
